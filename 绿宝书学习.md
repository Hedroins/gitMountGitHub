运算符优先级：（从小到大）
一级逗号运算符，二级展开紧接住
三级生成抛值出(yield) , 在接四级赋值符
五级三元搞特殊，六七逻辑或与与
八九按位或异或，按位与为第十级
十一判断等不等，十二比较（大于小于等序列检测）在（in）原型(instanceof)，
十三移位操作符，十四加减拼接串
十五乘除与取模，十六前置自加减
还有类型无二非，十七后置自增减
十八调用无残留（无参new）,
十九存取有残留（有参new）
二十分组你最牛



几种遍历对象属性的方法：
1、Object.keys()  只返回自身的显式属性 变体：Object.entries()、 Object.values()
2、Object.getOwnPropertyNames()  返回自身所有非Symbol属性
3、Object.getOwnPropertySymbols() 返回自身所有Symbol属性
4、for... in ...  遍历自身和继承的显式属性
5、Reflect.ownKeys() 返回对象自身所有的属性（包含Symbol属性）


delete运算符可以删除一个对象的指定属性
delete isNaN
但是delete不能删除以下的几种情况的属性：
1、不能删除let/var/const声明的变量
2、直接继承自原型的属性。

delete只会在删除一个不能删除的成员才会返回false,在其他情况，例如删除不存在的成员，或者删除继承自父类/原型的成员,即使删除不成功也会返回true
delete 不能删除宿主对象的成员，例如：delete window.avalue //false


with语句可以在代码块中直接以变量的形式操作对象的属性。

符号(Symbol)可以作为对象的成员名，也可以继承或基于原型访问，唯一不同的是，它通常需要特殊的方式才能枚举、存取和使用。

在一个模块中如果使用符号作为导出对象的属性名，在另一模块中也必须要引入这个符号才能取出模块中该属性的值。

Object.prototype所具备的基本成员：
toString、toLocalString 、 valueOf、constructor、propertyIsEnumerable、hasOwnProperty、isPrototypeOf.

构造器/函数所具有的特殊成员(继承自Object.__proto__)：
call , apply, bind, name, arguments, length, caller,prototype 

Object()的静态方法：
   原型相关：create()、getPrototypeOf()、setPrototypeOf().
   属性表项增删: assign()、 defineProperty()、defineProperties()
   属性表列举: getOwnPropertyNames()、keys()、getOwnPropertySymbols()、getOwnPropertyDescriptor()、entries()、values()           getOwnPropertyDescriptors()
   属性表状态: freeze()、seal()、preventExtensions()、isFrozen()、isSealed()、isExtensible()
   其他：is()

如果设置一个构造器的prototype属性为null, 这个构造器创造出的实例obj实际是调用Object()构造器创建的实例。
这种情况下是不能检测obj与这个构造器的类属关系的，因为变量构造器的原型链会得到null. 

如果调用Object.setPrototypeOf()方法将一个对象的原型设置为null,这个对象就只有一级的属性包(没有原型链),只存在自有属性，连Object的内置属性也没有继承
不过它具有对象的一切性质。


class Foo extends null {} 被称为纯静态类，继承自null,所以不能通过父类初始化实例，所以就不能使用new操作。
纯静态类只是"在语法上"不能用来做"构造函数"，而不是没有"构造函数",默认情况下，纯静态类使用的是一个默认的构造方法
，该构造方法总是调用super()来试图让父类构造对象实例，如果用户代码声明一个构造函数，以定制一个新的创建实例的过程，那么纯静态类也是可以被new使用的

new.target指向的是正在使用new操作调用的构造函数，如果构造函数不是通过new调用的，那么new.target的值就是undefined
new.target可以用来检测一个构造函数是否是通过new调用的。


对象系统的三要素：继承、封装、多态
面向对象编程中的封装，表达为private、protected等关键字限定的成员存取范围或作用域，以及对象在不同继承层次上对成员的叠加


instanceof和isPrototypeOf()方法都是用来检测一个对象是否属于某个类，instanceof检测的是右边操作数原型属性(aConstructor.prototype)的原型链， 而不是这个操作数本身（aConstructor）的原型链。
```javascript
let f1 = new Function();
let f2 = new Function();
Object.setPrototypeOf(f1,f2);
f1 instanceof f2 // false
f2.isPrototypeOf(f1) // true
```

箭头函数会忽略传入的this对象，即bind()、apply()或者call()等方法，以及在Array.forEach等方法中传入的this对象，对于箭头函数是无意义的。

super.xxx()和super() , 它们的this引用也是隐式传入的，this是当前构造的对象实例


Reflect.construct()方法接受三个参数，第一个参数是构造函数，第二个参数是构造函数的参数列表，第三个参数是构造函数的prototype对象
```javascript
let d = Reflect.construct(Date, [2020, 1, 1]);
d instanceof Date // true
```

